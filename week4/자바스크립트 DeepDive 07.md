![썸네일 : 모던 자바스크립트 Deep Dive](https://images.velog.io/images/kados22/post/e7e7c992-6bd1-440e-a4d8-e4eaec2320d8/image.png)

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 그리고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식 이다.

---

## 산술 연산자

- NaN_NotANumber_이 반환되는 경우 : 산술 연산이 불가능한 경우
### 이항 산술 연산자 : +, -, *, / %

### 단항 산술 연산자 : ++, --, (음양 표시)+, -
- 이항 산술 연산자와는 달리 피연산자의 값을 변경하는 효과가 있다.
- 증가/감소(++/--) 연산자는 위치에 의미가 있다.
  - 피연산자 앞에 위치 : 피연산자 값 증가/감소 ➡️ 다른 연산
  - 피연산자 뒤에 위치 : 다른 연산을 수행 ➡️ 피연산자 값 증가/ 감소
 
*_숫자 타입이 아닌 피연산자에 + 단항 연산자 ➡️ 숫자 타입으로 변환된 피연산자 값 반환_
_이때, 문자열은 숫자로 타입 변환할 수 없으므로 NaN을 반환한다._

### 문자여 연결 연산자 : +
피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

#### ❗암묵적 타입 변환_Implicit coercion_
`암묵적 타입 변환implicit coercion`, `타입 강제 변환type coercion` : 자바스크립트 엔진에 의해 개발자의 의도와는 상관없이 암묵적으로 타입이 자동 변환되는 경우.

```Javascript
1 + '2'; // ➡️ '12'

1 + true; // ➡️ 2 // true : 1
1 + false; // ➡️ 1 // false : 0
1 + null; // ➡️ 1 // null : 0
+undefined; // ➡️ NaN // undefined는 숫자 타입으로 변환 불가 
1 + undefined; // ➡️ NaN // undefined는 숫자 타입으로 변환 불가
```

--- 

## 할당 연산자

**🧃 `a=b=c=0;`이 가능한 이유는?**
➡️ 할당문은 **할당된 값으로 평가**되는 표현식인 문이기 때문이다.

### 동등/일치 비교 연산자 : ==, ===, !=, !==
** 🧃 == 보다 ===을 써야하는 이유는? **
➡️ 동등 비교 연산자(==)는 느슨한 비교를 하지만 일치 비교 연산자(===)는 엄격한 비교를 하기 때문이다.

- `==` : 암묵적 타입 변환 후에 같은 값일 수 있다면 true 반환
➡️ 예측하기 어려운 결과❗

- `===` : 암묵적 타입 변환을 하지 않고 값 비교
➡️ 타입도 같고 값도 같은 경우에 한하여 true 반환

**🧃  NaN을 비교하는 방법은 NaN === NaN이 아니다?**
NaN 은 자신과 일치하지 않는 유일한 값
➡️ 빌트인 함수 `Number.isNaN` 사용

*_`0 == -0;`, `0 === -0;`은 둘 다 true이다._

### 대소 관계 비교 연산자 : >, <, >=, <=

---

## 삼항 조건 연산자 : 조건식 ? A : B
`삼항 조건 연산자ternary operator` : `조건식`의 평가 결과에 따라 반환 값을 결정한다.
`조건식` : 불리언 타입의 값으로 평가될 표현식. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다.

** 🧃 삼항 연산자와 if ... else 문의 차이점은?**
➡️ 삼항 조건 연산자 표현식은 **값처럼 사용**할 수 있지만 if ... else 문은 그럴 수 없다.
삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이지만 if ... else 문은 표현식이 아닌 문이기 때문이다.

---

## 논리 연산자 : ||, &&, !

- 논리합(||) or 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 
두 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

- 논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 
단, 피연산자가 반드시 불리언 값일 필요는 없다. 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.


--- 

## 쉼표 연산자 : ,

`쉼표 연산자` : 왼쪽 피연산자부터 차례대로 피연산자를 평가한 뒤, 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

---

## 그룹 연산자 : ()
`그룹 연산자` : 소괄호('()')로 피연산자를 감싸서 자신의 피연산자인 표현식을 가장 먼저 평가한다.

---

## typeof 연산자 : typeof

- typeof 연산자는 7가지 문자열 _string_, _number_, _boolean_, _undefined_, _symbol_, _object_, _function_ 중 하나를 반환한다. 
- _null_ 을 반환하는 경우는 없다.

❗typeof 연산자가 반환하는 문자열은 **7개의 데이터 타입과 정확히 일치하지는 않는다**는 것을 주의해야한다.

** 🧃 typeof(null) = null❌ object⭕?**
이것은 자바 스크립트의 첫 번째 버전의 버그이다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다. 
➡️ 값이 **null 타입인지 확인할 때는 `===`**을 사용하자.

**🧃 선언하지 않은 식별자의 타입은?**
➡️ **undefined**
선언하지 않은 식별자를 typeof 연산자로 연산해 보면 _ReferenceError_가 발생하지 않고 _undefined_를 반환한다.

---

## 지수 연산자 : base ** exponent

`지수 연산자` : 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.

- ES7에서 도입
- 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다.
- 이항 연산자 중에서 우선순위가 가장 높다.

---

**🧃 부수 효과가 있는 연산자는?**
➡️ `=`(할당 연산자), `++ / --`(증가/감소 연산자), `delete 연산자`
